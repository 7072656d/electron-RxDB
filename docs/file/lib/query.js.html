<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/query.js | electron-RxDB API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/database-change-record-debouncer.js~DatabaseChangeRecordDebouncer.html">DatabaseChangeRecordDebouncer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/database-change-record.js~DatabaseChangeRecord.html">DatabaseChangeRecord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/database-object-registry.js~DatabaseObjectRegistry.html">DatabaseObjectRegistry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/database-store.js~DatabaseStore.html">DatabaseStore</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/database-transaction.js~DatabaseTransaction.html">DatabaseTransaction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/json-blob.js~JSONBlob.html">JSONBlob</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/model.js~Model.html">Model</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mutable-query-result-set.js~MutableQueryResultSet.html">MutableQueryResultSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/mutable-query-subscription.js~MutableQuerySubscription.html">MutableQuerySubscription</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query-range.js~QueryRange.html">QueryRange</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query-result-set.js~QueryResultSet.html">QueryResultSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query-subscription-pool.js~QuerySubscriptionPool.html">QuerySubscriptionPool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query-subscription.js~QuerySubscription.html">QuerySubscription</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/query.js~ModelQuery.html">ModelQuery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-logSQLString">logSQLString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-replacer">replacer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-reviver">reviver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-generateTempId">generateTempId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isTempId">isTempId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-modelFreeze">modelFreeze</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-registeredObjectReplacer">registeredObjectReplacer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-registeredObjectReviver">registeredObjectReviver</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-tableNameForJoin">tableNameForJoin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-registry">registry</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">attributes</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-boolean.js~AttributeBoolean.html">AttributeBoolean</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-collection.js~AttributeCollection.html">AttributeCollection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-datetime.js~AttributeDateTime.html">AttributeDateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-joined-data.js~AttributeJoinedData.html">AttributeJoinedData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-number.js~AttributeNumber.html">AttributeNumber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-object.js~AttributeObject.html">AttributeObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute-string.js~AttributeString.html">AttributeString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/attribute.js~Attribute.html">Attribute</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/matcher.js~Matcher.html">Matcher</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/attributes/sort-order.js~SortOrder.html">SortOrder</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">browser</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/browser/coordinator.js~Coordinator.html">Coordinator</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/query.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* eslint global-require: 0 */
/* eslint import/newline-after-import: 0 */
import Rx from &apos;rx-lite&apos;;
import Attributes from &apos;./attributes&apos;;
import QueryRange from &apos;./query-range&apos;;
import {registeredObjectReviver, tableNameForJoin} from &apos;./utils&apos;;

const {Matcher, AttributeJoinedData, AttributeCollection} = Attributes;

/**
ModelQuery exposes an ActiveRecord-style syntax for building database queries
that return models and model counts. Model queries are returned from the factory methods
{DatabaseStore::find}, {DatabaseStore::findBy}, {DatabaseStore::findAll},
and {DatabaseStore::count}, and are the primary interface for retrieving data
from the app&apos;s local cache.

ModelQuery does not allow you to modify the local cache. To create, update or
delete items from the local cache, see {DatabaseStore::inTransaction}
and {DatabaseTransaction::persistModel}.

**Simple Example:** Fetch a thread

```js
const query = db.find(Thread, &apos;123a2sc1ef4131&apos;);
query.then((thread) {
  // thread or null
});
```

**Advanced Example:** Fetch 50 threads in the inbox, in descending order

```coffee
const query = db.findAll(Thread);
query.where([Thread.attributes.categories.contains(&apos;label-id&apos;)])
     .order([Thread.attributes.lastMessageReceivedTimestamp.descending()])
     .limit(100).offset(50)
     .then((threads) {
  // array of threads
});
```
*/
export default class ModelQuery {

  /**
  @param {Model} class - A {Model} class to query
  @param {DatabaseStore} [database] - An optional reference to a {DatabaseStore}
    the query will be executed on.
  */
  constructor(klass, database) {
    this._klass = klass;
    this._database = database || require(&apos;./database-store&apos;).default;
    this._matchers = [];
    this._orders = [];
    this._distinct = false;
    this._range = QueryRange.infinite();
    this._returnOne = false;
    this._returnIds = false;
    this._includeJoinedData = [];
    this._count = false;
  }

  /**
  @returns {Query} - A deep copy of the Query that can be modified.
  */
  clone() {
    const q = new ModelQuery(this._klass, this._database).where(this._matchers).order(this._orders);
    q._orders = [].concat(this._orders);
    q._includeJoinedData = [].concat(this._includeJoinedData);
    q._range = this._range.clone();
    q._distinct = this._distinct;
    q._returnOne = this._returnOne;
    q._returnIds = this._returnIds;
    q._count = this._count;
    return q;
  }

  distinct() {
    this._distinct = true;
    return this;
  }

  /**
  Add one or more where clauses to the query
  This method is chainable.

  @param {Array} matchers - Array of {Matcher} objects that add where clauses
    to the underlying query.
  */
  where(matchers) {
    this._assertNotFinalized();

    if (matchers instanceof Matcher) {
      this._matchers.push(matchers);
    } else if (matchers instanceof Array) {
      for (const m of matchers) {
        if (!(m instanceof Matcher)) {
          throw new Error(&quot;You must provide instances of `Matcher`&quot;);
        }
      }
      this._matchers = this._matchers.concat(matchers);
    } else if (matchers instanceof Object) {
      // Support a shorthand format of {id: &apos;123&apos;, accountId: &apos;123&apos;}
      for (const key of Object.keys(matchers)) {
        const value = matchers[key];
        const attr = this._klass.attributes[key];
        if (!attr) {
          const msg = `Cannot create where clause \`${key}:${value}\`. ${key} is not an attribute of ${this._klass.name}`;
          throw new Error(msg);
        }

        if (value instanceof Array) {
          this._matchers.push(attr.in(value));
        } else {
          this._matchers.push(attr.equal(value));
        }
      }
    }
    return this;
  }

  whereAny(matchers) {
    this._assertNotFinalized();
    this._matchers.push(new Matcher.Or(matchers));
    return this;
  }

  search(query) {
    this._assertNotFinalized();
    this._matchers.push(new Matcher.Search(query));
    return this;
  }

  /**
  Include specific joined data attributes in result objects.

  @param {AttributeJoinedData} attr - Attribute that you want to be populated in
  the returned models. Note: This results in a LEFT OUTER JOIN.
  See {AttributeJoinedData} for more information.

  This method is chainable.
  */
  include(attr) {
    this._assertNotFinalized();
    if (!(attr instanceof AttributeJoinedData)) {
      throw new Error(&quot;query.include() must be called with a joined data attribute&quot;);
    }
    this._includeJoinedData.push(attr);
    return this;
  }

  /**
  Include all of the available joined data attributes in returned models.

  This method is chainable.
  */
  includeAll() {
    this._assertNotFinalized()
    for (const key of Object.keys(this._klass.attributes)) {
      const attr = this._klass.attributes[key];
      if (attr instanceof AttributeJoinedData) {
        this.include(attr);
      }
    }
    return this;
  }

  /**
  Apply a sort order to the query.

  @param {Array} orders - An {Array} of one or more {SortOrder} objects that
    determine the sort order of returned models.

  This method is chainable.
  */
  order(ordersOrOrder) {
    this._assertNotFinalized();
    const orders = (ordersOrOrder instanceof Array) ? ordersOrOrder : [ordersOrOrder];
    this._orders = this._orders.concat(orders);
    return this;
  }

  /**
  Set the `singular` flag - only one model will be returned from the
  query, and a `LIMIT 1` clause will be used.

  This method is chainable.
  */
  one() {
    this._assertNotFinalized();
    this._returnOne = true;
    return this;
  }

  /**
  Limit the number of query results.

  @param {Number} limit - The number of models that should be returned.

  This method is chainable.
  */
  limit(limit) {
    this._assertNotFinalized()
    if (this._returnOne &amp;&amp; limit &gt; 1) {
      throw new Error(&quot;Cannot use limit &gt; 1 with one()&quot;);
    }
    this._range = this._range.clone();
    this._range.limit = limit;
    return this;
  }

  /**
  @param {Number} offset - The start offset of the query.
  This method is chainable.
  */
  offset(offset) {
    this._assertNotFinalized();
    this._range = this._range.clone();
    this._range.offset = offset;
    return this;
  }

  /**
  A convenience method for setting both limit and offset given a desired page size.
  */
  page(start, end, pageSize = 50, pagePadding = 100) {
    const roundToPage = (n) =&gt; Math.max(0, Math.floor(n / pageSize) * pageSize)
    this.offset(roundToPage(start - pagePadding));
    this.limit(roundToPage((end - start) + pagePadding * 2));
    return this;
  }

  /**
  Set the `count` flag - instead of returning inflated models,
  the query will return the result `COUNT`.

  This method is chainable.
  */
  count() {
    this._assertNotFinalized();
    this._count = true;
    return this;
  }

  idsOnly() {
    this._assertNotFinalized();
    this._returnIds = true;
    return this;
  }

  // Query Execution

  /**
  Short-hand syntax that calls run().then(fn) with the provided function.

  @returns {Promise} - A promise that resolves with the Models returned by the
  query, or rejects with an error from the Database layer.
  */
  then(next) {
    return this.run(this).then(next);
  }

  /**
  @returns {Promise} - A Promise that resolves with the Models returned by the
  query, or rejects with an error from the Database layer.
  */
  run() {
    return this._database.run(this);
  }

  inflateResult(result) {
    if (!result) {
      return null;
    }

    if (this._count) {
      return result[0].count / 1;
    }
    if (this._returnIds) {
      return result.map(row =&gt; row.id);
    }

    try {
      return result.map((row) =&gt; {
        const json = JSON.parse(row.data, registeredObjectReviver)
        const object = (new this._klass()).fromJSON(json);
        for (const attr of this._includeJoinedData) {
          let value = row[attr.jsonKey];
          if (value === AttributeJoinedData.NullPlaceholder) {
            value = null;
          }
          object[attr.modelKey] = value;
        }
        return object;
      });
    } catch (jsonError) {
      throw new Error(`Query could not parse the database result. Query: ${this.sql()}, Error: ${jsonError.toString()}`);
    }
  }

  formatResult(inflated) {
    if (this._returnOne) {
      return inflated[0];
    }
    if (this._count) {
      return inflated;
    }
    return [].concat(inflated);
  }

  // Query SQL Building

  /**
  @returns {String} - The SQL generated for the query.
  */
  sql() {
    this.finalize();

    let result = null;

    if (this._count) {
      result = `COUNT(*) as count`;
    } else if (this._returnIds) {
      result = `\`${this._klass.name}\`.\`id\``;
    } else {
      result = `\`${this._klass.name}\`.\`data\``;
      this._includeJoinedData.forEach((attr) =&gt; {
        result += `, ${attr.selectSQL(this._klass)} `;
      })
    }

    const order = this._count ? &apos;&apos; : this._orderClause();

    let limit = &apos;&apos;;
    if (Number.isInteger(this._range.limit)) {
      limit = `LIMIT ${this._range.limit}`;
    } else {
      limit = &apos;&apos;
    }
    if (Number.isInteger(this._range.offset)) {
      limit += ` OFFSET ${this._range.offset}`;
    }

    const distinct = this._distinct ? &apos; DISTINCT&apos; : &apos;&apos;;
    const allMatchers = this.matchersFlattened();

    const joins = allMatchers.filter((matcher) =&gt; matcher.attr instanceof AttributeCollection)

    if ((joins.length === 1) &amp;&amp; this._canSubselectForJoin(joins[0], allMatchers)) {
      const subSql = this._subselectSQL(joins[0], this._matchers, order, limit);
      return `SELECT${distinct} ${result} FROM \`${this._klass.name}\` WHERE \`id\` IN (${subSql}) ${order}`;
    }

    return `SELECT${distinct} ${result} FROM \`${this._klass.name}\` ${this._whereClause()} ${order} ${limit}`;
  }

  // If one of our matchers requires a join, and the attribute configuration lists
  // all of the other order and matcher attributes in \`joinQueryableBy\`, it means
  // we can make the entire WHERE and ORDER BY on a sub-query, which improves
  // performance considerably vs. finding all results from the join table and then
  // doing the ordering after pulling the results in the main table.
  //
  // Note: This is currently only intended for use in the thread list
  //
  _canSubselectForJoin(matcher, allMatchers) {
    const joinAttribute = matcher.attribute();

    if (!Number.isInteger(this._range.limit)) {
      return false;
    }

    const allMatchersOnJoinTable = allMatchers.every((m) =&gt;
      (m === matcher) || (joinAttribute.joinQueryableBy.includes(m.attr.modelKey)) || (m.attr.modelKey === &apos;id&apos;)
    );
    const allOrdersOnJoinTable = this._orders.every((o) =&gt;
      (joinAttribute.joinQueryableBy.includes(o.attr.modelKey))
    );

    return (allMatchersOnJoinTable &amp;&amp; allOrdersOnJoinTable);
  }

  _subselectSQL(returningMatcher, subselectMatchers, order, limit) {
    const returningAttribute = returningMatcher.attribute()

    const table = tableNameForJoin(this._klass, returningAttribute.itemClass);
    const wheres = subselectMatchers.map(c =&gt; c.whereSQL(this._klass)).filter(c =&gt; !!c);

    let innerSQL = `SELECT \`id\` FROM \`${table}\` WHERE ${wheres.join(&apos; AND &apos;)} ${order} ${limit}`;
    innerSQL = innerSQL.replace(new RegExp(`\`${this._klass.name}\``, &apos;g&apos;), `\`${table}\``);
    innerSQL = innerSQL.replace(new RegExp(`\`${returningMatcher.joinTableRef()}\``, &apos;g&apos;), `\`${table}\``);
    return innerSQL;
  }

  _whereClause() {
    const joins = [];
    this._matchers.forEach((c) =&gt; {
      const join = c.joinSQL(this._klass)
      if (join) {
        joins.push(join);
      }
    });

    this._includeJoinedData.forEach((attr) =&gt; {
      const join = attr.includeSQL(this._klass)
      if (join) {
        joins.push(join);
      }
    });

    const wheres = [];
    this._matchers.forEach(c =&gt; {
      const where = c.whereSQL(this._klass);
      if (where) {
        wheres.push(where)
      }
    });

    let sql = joins.join(&apos; &apos;)
    if (wheres.length &gt; 0) {
      sql += ` WHERE ${wheres.join(&apos; AND &apos;)}`;
    }
    return sql;
  }

  _orderClause() {
    if (this._orders.length === 0) {
      return &apos;&apos;
    }

    let sql = &apos; ORDER BY &apos;
    this._orders.forEach((sort) =&gt; {
      sql += sort.orderBySQL(this._klass);
    });
    return sql;
  }

  // Private: Marks the object as final, preventing any changes to the where
  // clauses, orders, etc.
  finalize() {
    if (this._finalized) {
      return this;
    }

    if (this._orders.length === 0) {
      const natural = this._klass.naturalSortOrder();
      if (natural) {
        this._orders.push(natural);
      }
    }

    if (this._returnOne &amp;&amp; !this._range.limit) {
      this.limit(1);
    }

    this._finalized = true;
    return this;
  }

  // Private: Throws an exception if the query has been frozen.
  _assertNotFinalized() {
    if (this._finalized) {
      throw new Error(`ModelQuery: You cannot modify a query after calling \`then\` or \`listen\``);
    }
  }

  // Observables

  observe({allowQueryChanges = false, name = null} = {}) {
    return Rx.Observable.create((observer) =&gt; {
      const pool = this._database._subscriptionPool;
      let unsubscribe = null;
      if (allowQueryChanges) {
        unsubscribe = pool.addPrivateSubscription(name, this, (v) =&gt; observer.onNext(v));
      } else {
        unsubscribe = pool.add(this, (v) =&gt; observer.onNext(v));
      }
      return Rx.Disposable.create(unsubscribe);
    });
  }

  // Introspection
  // (These are here to make specs easy)

  matchers() {
    return this._matchers;
  }

  matchersFlattened() {
    const all = []
    const traverse = (matchers) =&gt; {
      if (!(matchers instanceof Array)) {
        return;
      }
      for (const m of matchers) {
        if (m.children) {
          traverse(m.children);
        } else {
          all.push(m);
        }
      }
    }
    traverse(this._matchers);
    return all;
  }

  matcherValueForModelKey(key) {
    const matcher = this._matchers.find(m =&gt; m.attr.modelKey === key)
    return matcher ? matcher.val : null;
  }

  range() {
    return this._range;
  }

  orderSortDescriptors() {
    return this._orders;
  }

  objectClass() {
    return this._klass.name;
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.8)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
